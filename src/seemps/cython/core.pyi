from enum import IntEnum
import numpy as np
from ..typing import Vector, Unitary, Tensor3, Tensor4, Environment, Weight

MAX_BOND_DIMENSION: int

class Truncation(IntEnum):
    DO_NOT_TRUNCATE = 0
    RELATIVE_SINGULAR_VALUE = 1
    RELATIVE_NORM_SQUARED_ERROR = 2
    ABSOLUTE_SINGULAR_VALUE = 3

class Simplification(IntEnum):
    DO_NOT_SIMPLIFY = 0
    CANONICAL_FORM = 1
    VARIATIONAL = 2
    VARIATIONAL_EXACT_GUESS = 3

class Strategy:
    def __init__(
        self: Strategy,
        method: Truncation = Truncation.RELATIVE_SINGULAR_VALUE,
        tolerance: float = 1e-8,
        simplification_tolerance: float = 1e-8,
        max_bond_dimension: int = 0x8FFFFFFF,
        max_sweeps: int = 16,
        normalize: bool = False,
        simplify: Simplification = Simplification.VARIATIONAL,
    ): ...
    def replace(
        self: Strategy,
        method: Truncation | None = None,
        tolerance: float | None = None,
        simplification_tolerance: float | None = None,
        max_bond_dimension: int | None = None,
        max_sweeps: int | None = None,
        normalize: bool | None = None,
        simplify: Simplification | None = None,
    ) -> Strategy: ...
    def set_normalization(self: Strategy, normalize: bool) -> Strategy: ...
    def get_tolerance(self) -> float: ...
    def get_simplification_tolerance(self) -> float: ...
    def get_simplification_method(self) -> Simplification: ...
    def get_max_bond_dimension(self) -> int: ...
    def get_max_sweeps(self) -> int: ...
    def get_method(self) -> int: ...
    def get_normalize_flag(self) -> bool: ...
    def get_simplify_flag(self) -> bool: ...
    def __str__(self) -> str: ...

DEFAULT_TOLERANCE: float

NO_TRUNCATION: Strategy

DEFAULT_STRATEGY: Strategy

def destructively_truncate_vector(s: Vector, strategy: Strategy) -> float: ...
def _contract_nrjl_ijk_klm(U: Unitary, A: Tensor3, B: Tensor3) -> Tensor4: ...
def _contract_last_and_first(A: np.ndarray, B: np.ndarray) -> np.ndarray: ...
def _begin_environment(D: int | None = 1) -> Environment: ...
def _update_right_environment(
    B: Tensor3, A: Tensor3, rho: Environment
) -> Environment: ...
def _update_left_environment(
    B: Tensor3, A: Tensor3, rho: Environment
) -> Environment: ...
def _end_environment(rho: Environment) -> Weight: ...
def _join_environments(rhoL: Environment, rhoR: Environment) -> Weight: ...
def scprod(bra: MPS, ket: MPS) -> Weight: ...
def vdot(bra: MPS, ket: MPS) -> Weight: ...
def _update_in_canonical_form_left(
    state: list[Tensor3], A: Tensor3, site: int, truncation: Strategy
) -> tuple[int, float]: ...
def _update_in_canonical_form_right(
    state: list[Tensor3], A: Tensor3, site: int, truncation: Strategy
) -> tuple[int, float]: ...
def _canonicalize(state: list[Tensor3], center: int, truncation: Strategy) -> float: ...
def _recanonicalize(
    state: list[Tensor3], oldcenter: int, newcenter: int, truncation: Strategy
) -> float: ...
def _left_orth_2site(
    AA: Tensor4, strategy: Strategy
) -> tuple[Tensor3, Tensor3, float]: ...
def _right_orth_2site(
    AA: Tensor4, strategy: Strategy
) -> tuple[Tensor3, Tensor3, float]: ...
def _select_svd_driver(which: str): ...
def _destructive_svd(A: np.ndarray) -> tuple[np.ndarray, np.ndarray, np.ndarray]: ...

class GemmOrder(IntEnum):
    NORMAL = 0
    TRANSPOSE = 1
    ADJOINT = 2

def _gemm(B: np.ndarray, BT: GemmOrder, A: np.ndarray, AT: GemmOrder) -> np.ndarray: ...

from ..state.mps import MPS  # noqa: E402
